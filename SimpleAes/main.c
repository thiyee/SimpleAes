#include <Windows.h>
#include <intrin.h>
#include <stdlib.h>
#include <stdio.h>
typedef union _UINT128{
		UINT64	i64[2];
		UINT32	i32[4];
		UINT16	i16[8];
		UINT8	i8[16];
		UINT8	i8_4x4[4][4];
}UINT128,*PUINT128;

VOID MakeByteMap() {
	UINT8 Map[0x100];
	UINT8 RMap[0x100];
	for (int i = 0; i < 0x100; i++) Map[i] = i;
	for (int i = 0; i < 0x100; i++) {
		int TargetIndex = rand() % 0x100;
		UINT8 TempValue = Map[TargetIndex];
		Map[TargetIndex] = Map[i];
		Map[i] = TempValue;
	}
	for (int i = 0; i < 0x100; i++) {
		RMap[Map[i]] = i;
	}
	for (int i = 0; i < 0x10; i++) {
		for (int j = 0; j < 0x10; j++) {
			printf("0x%02x,", Map[i * 0x10 + j]);
		}
		printf("\n");
	}

	printf("\n");
	for (int i = 0; i < 0x10; i++) {
		for (int j = 0; j < 0x10; j++) {
			printf("0x%02x,", RMap[i * 0x10 + j]);
		}
		printf("\n");
	}
}

#pragma code_seg(".text")
__declspec(allocate(".text")) unsigned char Rol64[] = {
	0x48,0x8B,0xC1,			//mov     rax, rcx
	0x8A,0xCA,				//mov     cl, dl
	0x48,0xD3,0xC0,			//rol     rax, cl
	0xC3					//ret
};
__declspec(allocate(".text")) unsigned char Rol32[] = {
	0x8B,0xC1,				//mov     eax, ecx
	0x8A,0xCA,				//mov     cl, dl
	0xD3,0xC0,				//rol     eax, cl
	0xC3					//ret
};
__declspec(allocate(".text")) unsigned char Rol16[] = {
	0x66,0x8b,0xc1,			//mov     ax, cx
	0x8a,0xca,				//mov     cl, dl
	0x66,0xd3,0xc0,			//rol     ax, cl
	0xc3					//ret
};
__declspec(allocate(".text")) unsigned char Rol8[] = {
	0x8a,0xc1,				//mov al,cl
	0x8a,0xca,				//mov cl,dl
	0xd2,0xc0,				//rol al,cl
	0xc3					//ret
};
__declspec(allocate(".text")) unsigned char Ror64[] = {
	0x48,0x8B,0xC1,			//mov     rax, rcx
	0x8A,0xCA,				//mov     cl, dl
	0x48,0xD3,0xC8,			//rol     rax, cl
	0xC3					//ret
};
__declspec(allocate(".text")) unsigned char Ror32[] = {
	0x8B,0xC1,				//mov     eax, ecx
	0x8A,0xCA,				//mov     cl, dl
	0xD3,0xC8,				//rol     eax, cl
	0xC3					//ret
};
__declspec(allocate(".text")) unsigned char Ror16[] = {
	0x66,0x8b,0xc1,			//mov     ax, cx
	0x8a,0xca,				//mov     cl, dl
	0x66,0xd3,0xc8,			//rol     ax, cl
	0xc3					//ret
};
__declspec(allocate(".text")) unsigned char Ror8[] = {
	0x8a,0xc1,				//mov al,cl
	0x8a,0xca,				//mov cl,dl
	0xd2,0xc8,				//rol al,cl
	0xc3					//ret
};

#define ROR64(x,n) ((UINT64(__fastcall*)(UINT64,UINT8))Ror64)(x,n)
#define ROR32(x,n) ((UINT32(__fastcall*)(UINT32,UINT8))Ror32)(x,n)
#define ROR16(x,n) ((UINT16(__fastcall*)(UINT16,UINT8))Ror16)(x,n)
#define ROR8(x,n) ((UINT8(__fastcall*)(UINT8,UINT8))Ror8)(x,n)
#define ROL64(x,n) ((UINT64(__fastcall*)(UINT64,UINT8))Rol64)(x,n)
#define ROL32(x,n) ((UINT32(__fastcall*)(UINT32,UINT8))Rol32)(x,n)
#define ROL16(x,n) ((UINT16(__fastcall*)(UINT16,UINT8))Rol16)(x,n)
#define ROL8(x,n) ((UINT8(__fastcall*)(UINT8,UINT8))Rol8)(x,n)


//S盒
UINT8 SBox[0x100] = {
0xc1,0x23,0xa0,0x00,0x3a,0x73,0x1b,0x3d,0x52,0x2c,0x37,0xf1,0x42,0x39,0x53,0xeb,
0xb3,0xa6,0xa8,0x2d,0x81,0x0f,0xba,0x99,0xe0,0x5e,0xbb,0x1c,0x13,0xc6,0xa9,0xdf,
0x40,0xdb,0x05,0xc8,0x43,0x2e,0x8b,0x11,0xde,0x84,0xc7,0x27,0xa4,0x77,0x0d,0x35,
0x2a,0xd4,0xb8,0xdd,0x96,0xb6,0x46,0x3b,0x3c,0xa3,0x89,0x85,0xd6,0x12,0x76,0xcb,
0x55,0x9a,0x50,0xee,0xbc,0x78,0xed,0xfd,0xc0,0x65,0xfb,0xf6,0x9e,0x2b,0x0a,0x94,
0xd2,0xdc,0x87,0xa5,0x01,0x44,0x66,0x1e,0x6b,0xb4,0x5d,0x1d,0x4a,0x49,0xa1,0x92,
0x4b,0xaf,0x91,0x9d,0xe4,0x26,0x14,0x60,0xfe,0x79,0x18,0xbe,0xb9,0x72,0x63,0x4e,
0x64,0x80,0x98,0x0c,0xab,0xc3,0x8d,0x9f,0x25,0xea,0xc9,0xd8,0xf2,0xbf,0xb5,0x06,
0x22,0x62,0x1f,0x88,0x95,0xa2,0x8e,0xce,0xda,0xef,0xd0,0x6f,0x5f,0x82,0xca,0xc2,
0x02,0xcd,0xe2,0x47,0x6e,0x9c,0x9b,0x7e,0x97,0xe6,0xb7,0xf0,0x38,0x51,0xac,0xb1,
0x58,0xd7,0xe8,0x1a,0x20,0x7c,0x32,0x7a,0x48,0x93,0xfc,0x6a,0x3f,0x15,0xf4,0x75,
0x31,0xe7,0x68,0x70,0xc4,0x83,0xf5,0xcf,0x5c,0x61,0x16,0x7b,0x5b,0xd3,0x19,0x03,
0xa7,0xbd,0x8f,0xd5,0x74,0xd9,0x41,0x5a,0xe5,0x21,0xf7,0x7d,0xb2,0x08,0x59,0x54,
0x33,0x4d,0xad,0x29,0xec,0x09,0xff,0x8c,0xcc,0xf3,0xe3,0xae,0x30,0xaa,0x7f,0x56,
0x24,0x90,0xd1,0x0b,0x04,0x10,0x2f,0x71,0x4f,0x07,0x86,0x67,0xf8,0x45,0x17,0xe1,
0x3e,0xc5,0x57,0x6c,0x34,0x28,0x6d,0xf9,0x36,0xb0,0x4c,0xfa,0xe9,0x8a,0x69,0x0e
};
//逆S盒
UINT8 DSBox[0x100] = {
0x03,0x54,0x90,0xbf,0xe4,0x22,0x7f,0xe9,0xcd,0xd5,0x4e,0xe3,0x73,0x2e,0xff,0x15,
0xe5,0x27,0x3d,0x1c,0x66,0xad,0xba,0xee,0x6a,0xbe,0xa3,0x06,0x1b,0x5b,0x57,0x82,
0xa4,0xc9,0x80,0x01,0xe0,0x78,0x65,0x2b,0xf5,0xd3,0x30,0x4d,0x09,0x13,0x25,0xe6,
0xdc,0xb0,0xa6,0xd0,0xf4,0x2f,0xf8,0x0a,0x9c,0x0d,0x04,0x37,0x38,0x07,0xf0,0xac,
0x20,0xc6,0x0c,0x24,0x55,0xed,0x36,0x93,0xa8,0x5d,0x5c,0x60,0xfa,0xd1,0x6f,0xe8,
0x42,0x9d,0x08,0x0e,0xcf,0x40,0xdf,0xf2,0xa0,0xce,0xc7,0xbc,0xb8,0x5a,0x19,0x8c,
0x67,0xb9,0x81,0x6e,0x70,0x49,0x56,0xeb,0xb2,0xfe,0xab,0x58,0xf3,0xf6,0x94,0x8b,
0xb3,0xe7,0x6d,0x05,0xc4,0xaf,0x3e,0x2d,0x45,0x69,0xa7,0xbb,0xa5,0xcb,0x97,0xde,
0x71,0x14,0x8d,0xb5,0x29,0x3b,0xea,0x52,0x83,0x3a,0xfd,0x26,0xd7,0x76,0x86,0xc2,
0xe1,0x62,0x5f,0xa9,0x4f,0x84,0x34,0x98,0x72,0x17,0x41,0x96,0x95,0x63,0x4c,0x77,
0x02,0x5e,0x85,0x39,0x2c,0x53,0x11,0xc0,0x12,0x1e,0xdd,0x74,0x9e,0xd2,0xdb,0x61,
0xf9,0x9f,0xcc,0x10,0x59,0x7e,0x35,0x9a,0x32,0x6c,0x16,0x1a,0x44,0xc1,0x6b,0x7d,
0x48,0x00,0x8f,0x75,0xb4,0xf1,0x1d,0x2a,0x23,0x7a,0x8e,0x3f,0xd8,0x91,0x87,0xb7,
0x8a,0xe2,0x50,0xbd,0x31,0xc3,0x3c,0xa1,0x7b,0xc5,0x88,0x21,0x51,0x33,0x28,0x1f,
0x18,0xef,0x92,0xda,0x64,0xc8,0x99,0xb1,0xa2,0xfc,0x79,0x0f,0xd4,0x46,0x43,0x89,
0x9b,0x0b,0x7c,0xd9,0xae,0xb6,0x4b,0xca,0xec,0xf7,0xfb,0x4a,0xaa,0x47,0x68,0xd6
};
UINT128 KeyExtened[11];
static int GFMul2(int s) {
	int result = s << 1;
	int a7 = result & 0x00000100;

	if (a7 != 0) {
		result = result & 0x000000ff;
		result = result ^ 0x1b;
	}

	return result;
}
unsigned char GFMul(unsigned char a, unsigned char n) {
	switch (n) {
	case 0:
		return 0;
	case 1:
		return a;
	case 2:
		return GFMul2(a);
	case 3:
		return GFMul2(a) ^ a;
	case 4:
		return GFMul2(GFMul2(a));
	case 5:
		return GFMul2(GFMul2(a)) ^ a;
	case 6:
		return GFMul2(GFMul2(a)) ^ GFMul2(a);
	case 7:
		return GFMul2(GFMul2(a)) ^ GFMul2(a) ^ a;
	case 8:
		return GFMul2(GFMul2(GFMul2(a)));
	case 9:
		return GFMul2(GFMul2(GFMul2(a))) ^ a;
	case 10:
		return GFMul2(GFMul2(GFMul2(a))) ^ GFMul2(a);
	case 11:
		return GFMul2(GFMul2(GFMul2(a))) ^ GFMul2(a) ^ a;
	case 12:
		return GFMul2(GFMul2(GFMul2(a))) ^ GFMul2(GFMul2(a));
	case 13:
		return GFMul2(GFMul2(GFMul2(a))) ^ GFMul2(GFMul2(a)) ^ a;
	case 14:
		return GFMul2(GFMul2(GFMul2(a))) ^ GFMul2(GFMul2(a)) ^ GFMul2(a);
	case 15:
		return GFMul2(GFMul2(GFMul2(a))) ^ GFMul2(GFMul2(a)) ^ GFMul2(a) ^ a;
	case 16:
		return GFMul2(GFMul2(GFMul2(a))) ^ GFMul2(GFMul2(GFMul2(a)));
	default:
		return 0;
	}
}

//行位移
UINT64 ShiftRow(PUINT128 Data) {
	Data->i32[1] =ROR32(Data->i32[1], 1 * 8);
	Data->i32[2] =ROR32(Data->i32[2], 2 * 8);
	Data->i32[3] =ROR32(Data->i32[3], 3 * 8);
}
//逆行位移
UINT64 DeShiftRow(PUINT128 Data) {
	Data->i32[1] =ROL32(Data->i32[1], 1 * 8);
	Data->i32[2] =ROL32(Data->i32[2], 2 * 8);
	Data->i32[3] =ROL32(Data->i32[3], 3 * 8);
}
//列混合
VOID MixColumns(PUINT128 Data) {
	//static UINT128 colM = { .i8_4x4 = 
	//	{
	//	{2,3,1,1},
	//	{1,2,3,1},
	//	{1,1,2,3},
	//	{3,1,1,2}
	//	} 
	//};
	//防止被扫描到AES特征 使用加密的混合矩阵
	static UINT128 colM = { .i8_4x4 = 
		{
		{0x39,0x29,0x6c,0x6f},
		{0xff,0xb7,0xc1,0x1b},
		{0xa7,0xd7,0xf7,0xdc},
		{0x2d,0x1a,0xa7,0x17}
		} 
	};
	colM.i64[0] ^= 0x1ac2b5fe6e6d2a3b;
	colM.i64[1] ^= 0x15a61b2edff5d6a6;
	UINT128 Temp = *Data;
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++) 
			Data->i8_4x4[i][j]= GFMul(Temp.i8_4x4[0][j],colM.i8_4x4[i][0]) ^ GFMul(Temp.i8_4x4[1][j],colM.i8_4x4[i][1] ) ^ GFMul(Temp.i8_4x4[2][j],colM.i8_4x4[i][2]) ^ GFMul(Temp.i8_4x4[3][j],colM.i8_4x4[i][3] );

	colM.i64[0] ^= 0x1ac2b5fe6e6d2a3b;
	colM.i64[1] ^= 0x15a61b2edff5d6a6;

}
//逆列混合
VOID DeMixColumns(PUINT128 Data) {
	//static UINT128 colM = { .i8_4x4 = 
	//	{
	//	{0xe, 0xb, 0xd, 0x9},
	//	{0x9, 0xe, 0xb, 0xd},
	//	{0xd, 0x9, 0xe, 0xb},
	//	{0xb, 0xd, 0x9, 0xe}
	//	} 
	//};
	//防止被扫描到AES特征 使用加密的混合矩阵
	static UINT128 colM = { .i8_4x4 = 
		{
		{0x35, 0x21, 0x5c, 0xb3},
		{0xd5, 0xe1, 0xa0, 0x2c},
		{0x37, 0xf2, 0xdd, 0x55},
		{0xad, 0x6c, 0x63, 0x1b}
		} 
	};
	colM.i64[0] ^= 0x21abefdcba512a3b;
	colM.i64[1] ^= 0x156a61a65ed3fb3a;
	UINT128 Temp = *Data;
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++) 
			Data->i8_4x4[i][j]= GFMul(Temp.i8_4x4[0][j],colM.i8_4x4[i][0]) ^ GFMul(Temp.i8_4x4[1][j],colM.i8_4x4[i][1] ) ^ GFMul(Temp.i8_4x4[2][j],colM.i8_4x4[i][2] ) ^ GFMul(Temp.i8_4x4[3][j],colM.i8_4x4[i][3]);

	colM.i64[0] ^= 0x21abefdcba512a3b;
	colM.i64[1] ^= 0x156a61a65ed3fb3a;

}
//字节代换
VOID SubBytes(PUINT128 Data) {
	for (int i = 0; i < 16; i++) {
		Data->i8[i] = SBox[Data->i8[i]];
	}
}
//逆字节代换
VOID DeSubBytes(PUINT128 Data) {
	for (int i = 0; i < 16; i++) {
		Data->i8[i] = DSBox[Data->i8[i]];
	}
}
//128位异或
UINT128 Xor128(UINT128 Data1, UINT128 Data2) {
	UINT128 ret = {.i64[0]= Data1.i64[0]^Data2.i64[0],.i64[1] = Data1.i64[1] ^ Data2.i64[1] };
	return ret;
}
VOID RoundKeyExtension(UINT128 KeyData) {
	static UINT32 Rcon[] = { 0x1,0x2,0x4,0x8,0x10,0x20,0x40,0x80,0x1b,0x36 };

	KeyExtened[0] = KeyData;
	for (INT i = 1, j = 0; i < 11; i++) {
		UINT128 Temp= KeyExtened[i-1];
		Temp.i32[0] = ROL32(Temp.i32[0],8);										//字循环
		Temp.i8_4x4[0][0] = SBox[Temp.i8_4x4[0][0]];							//字节代换
		Temp.i8_4x4[0][1] = SBox[Temp.i8_4x4[0][1]];
		Temp.i8_4x4[0][2] = SBox[Temp.i8_4x4[0][2]];
		Temp.i8_4x4[0][3] = SBox[Temp.i8_4x4[0][3]];
		KeyExtened[i].i32[0] = KeyExtened[i - 1].i32[0] ^ Temp.i32[0]^ Rcon[i-1];
		KeyExtened[i].i32[1] = KeyExtened[i - 1].i32[1] ^ KeyExtened[i - 1].i32[0];
		KeyExtened[i].i32[2] = KeyExtened[i - 1].i32[2] ^ KeyExtened[i - 1].i32[1];
		KeyExtened[i].i32[3] = KeyExtened[i - 1].i32[3] ^ KeyExtened[i - 1].i32[2];
	}

}

/// <summary>
/// AES128加密
/// </summary>
/// <param name="Data">明文数据</param>
/// <param name="Length">明文数据长度(字节)</param>
/// <param name="KeyData">密钥</param>
/// <param name="OutBytes">输出密文长度</param>
/// <returns>密文指针 需使用VirtualFree释放</returns>
PUINT128 Aes128(PVOID Data,UINT64 Length, UINT128 KeyData,UINT64* OutBytes) {
	UINT64 ExtenedLength = 16 - (Length % 16);
	UINT64 AlignLength = Length+ ExtenedLength;

	PUINT128 Data128 = VirtualAlloc(0, AlignLength, MEM_COMMIT, PAGE_READWRITE);// malloc(AlignLength);
	memset(Data128, ExtenedLength, AlignLength);
	memcpy(Data128, Data, Length);
	
	RoundKeyExtension(KeyData);	
	//for (int i = 0; i < AlignLength / 16; i++) {//初始变换
	//	Data128[i].i64[0] ^= KeyData.i64[0];
	//	Data128[i].i64[1] ^= KeyData.i64[1];
	//}
	for (int i = 0; i < AlignLength / 16; i++) {
		Data128[i] = Xor128(Data128[i], KeyExtened[0]);		//轮密钥加
		for (int j = 1; j <= 9; j++) {
			SubBytes(&Data128[i]);							//字节代换
			ShiftRow(&Data128[i]);							//行位移
			MixColumns(&Data128[i]);						//列混合
			Data128[i] = Xor128(Data128[i], KeyExtened[j]);	//轮密钥加
		}
		SubBytes(&Data128[i]);								//字节代换
		ShiftRow(&Data128[i]);								//行位移
		Data128[i] = Xor128(Data128[i], KeyExtened[10]);	//轮密钥加
	}

	*OutBytes = AlignLength;
	return Data128;
}
/// <summary>
/// AES128解密 对使用Aes128函数加密的函数进行解密
/// </summary>
/// <param name="Data128">密文数据</param>
/// <param name="Length">密文数据长度</param>
/// <param name="KeyData">密钥</param>
/// <param name="OutBytes">明文数据长度</param>
/// <returns>指向明文数据的指针 无需释放</returns>
PVOID DeAes128(PUINT128 Data128, UINT64 Length, UINT128 KeyData, UINT64* OutBytes) {
	if (Length % 0x10) {
		printf("密文字符长度必须为16的倍数！现在的长度为%d\n", Length);
		return NULL;
	}
	RoundKeyExtension(KeyData);
	for (int i = 0; i < Length / 16; i++) {
		Data128[i] = Xor128(Data128[i], KeyExtened[10]);		//轮密钥加
		DeShiftRow(&Data128[i]);								//逆行位移
		DeSubBytes(&Data128[i]);								//逆字节代换
		for (int j = 9; j >= 1; j--) {
			Data128[i] = Xor128(Data128[i], KeyExtened[j]);		//轮密钥加
			DeMixColumns(&Data128[i]);							//逆列混合
			DeShiftRow(&Data128[i]);							//逆行位移
			DeSubBytes(&Data128[i]);							//逆字节代换
		}
		Data128[i] = Xor128(Data128[i], KeyExtened[0]);			//轮密钥加
	}
	*OutBytes = Length - Data128[(Length / 16) - 1].i8_4x4[3][3];
	return Data128;
}

void main() {

	//MakeByteMap();
	UINT128 Key = {.i8="asdasdasdasdiha"};
	char data[] = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

	UINT64 EncodedLength = 0,DecodedLength=0;

	PUINT128 EncodedData=Aes128(data, sizeof(data), Key, &EncodedLength);
	char* DecodedData=DeAes128(EncodedData, EncodedLength, Key,&DecodedLength);
	printf(DecodedData);
	getchar();
}